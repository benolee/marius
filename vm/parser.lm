
%include {
#include "parser_state.hpp"
#include "parser_tokens.h"
#include <iostream>
}

%name mariusParser

%token_type   { marius::ParserToken }
%default_type { marius::ParserToken }

%token_prefix TK_

%left PLUS MINUS.
%left DIVIDE TIMES.
%left DEQUAL NEQUAL NOT.

%extra_argument { marius::ParserState* S }

%syntax_error {
  S->set_syntax_error();

  std::cout << "Syntax error at line " << S->line()
            << ", column " << S->column() << std::endl;
}

program ::= opt_fin l1(A) last_fin. { S->set_top(S->ret(A.a)); }

l1(A) ::= l1(B) fin l1e(C). { A.a = S->seq(B.a, C.a); }
l1(A) ::= l1e(B).    { A.a = B.a; }

l1e(A) ::= class(B). { A.a = B.a; }
l1e(A) ::= def(B).   { A.a = B.a; }
l1e(A) ::= stmt(B).  { A.a = B.a; }

opt_fin ::= .
opt_fin ::= opt_fin FIN.

last_fin ::= EOF.
last_fin ::= fin EOF.

fin ::= fin FIN.
fin ::= FIN.

seq(A) ::= seq(B) fin stmt(C). { A.a = S->seq(B.a, C.a); }
seq(A) ::= stmt(B). { A.a = B.a; }

class_start ::= CLASS. { S->start_class(); }
class_body(A) ::= l1(B) fin END. { A.a = B.a; }

class(A) ::= class_start ID(B) fin class_body(C). {
               A.a = S->ast_class(*B.s, 0, C.a);
             }

class(A) ::= class_start ID(B) LT expr(C) fin class_body(D). {
               A.a = S->ast_class(*B.s, C.a, D.a);
             }

def_start ::= DEF. { S->start_def(); }
def_body(A) ::= seq(B) fin END. { A.a = B.a; }

id_list ::= id_list COMMA ID(A). { S->def_arg(*A.s); }
id_list ::= ID(A). { S->def_arg(*A.s); }

def_args ::= .
def_args ::= LP id_list RP.

def(A) ::= def_start ID(B) def_args fin def_body(C). {
              A.a = S->ast_def(*B.s, C.a);
            }

expr(A) ::= expr(B) MINUS  expr(C). { A.a = S->ast_binop("-", B.a, C.a); }
expr(A) ::= expr(B) PLUS   expr(C). { A.a = S->ast_binop("+", B.a, C.a); }
expr(A) ::= expr(B) TIMES  expr(C). { A.a = S->ast_binop("*", B.a, C.a); }
expr(A) ::= expr(B) DIVIDE expr(C). { A.a = S->ast_binop("/", B.a, C.a); }
expr(A) ::= expr(B) DEQUAL expr(C). { A.a = S->ast_binop("==", B.a, C.a); }
expr(A) ::= expr(B) NEQUAL expr(C). { A.a = S->not_(S->ast_binop("==", B.a, C.a)); }
expr(A) ::= NOT expr(B). { A.a = S->not_(B.a); }

sexpr(A) ::= NUM(B).                   { A.a = S->number(B.i); }
sexpr(A) ::= NIL.                      { A.a = S->ast_nil();  }
sexpr(A) ::= TRUE.                     { A.a = S->ast_true();  }
sexpr(A) ::= FALSE.                    { A.a = S->ast_false(); }
sexpr(A) ::= SELF.                     { A.a = S->self(); }
sexpr(A) ::= ID(B).                    { A.a = S->named(*B.s); }
sexpr(A) ::= IVAR(B).                  { A.a = S->ivar_read(*B.s); }
sexpr(A) ::= COLON ID(B).              { A.a = S->lit_str(*B.s); }
sexpr(A) ::= LITSTR(B).                { A.a = S->lit_str(*B.s); }

send(A) ::= sexpr(B). { A.a = B.a; }
send(A) ::= send(B) DOT ID(C). { A.a = S->call(B.a, *C.s); }
send(A) ::= send(B) ATTR ID(C). { A.a = S->attr(B.a, *C.s); }
send(A) ::= send(B) DCOLON(C) ID(D). { A.a = S->dcolon(B.a, *C.s, *D.s); }
send(A) ::= send(B) COLON ID(C). { A.a = S->cast(B.a, S->named(*C.s)); }

/* Positional args */

arg_list_start ::= LP. { S->start_arg_list(); }
arg_list_elems ::= arg_list_elems COMMA expr(A). { S->add_arg(A.a); }
arg_list_elems ::= expr(A). { S->add_arg(A.a); }

opt_kw_arg_list ::= .
opt_kw_arg_list ::= COMMA kw_arg_list_elems.

arg_list ::= arg_list_start arg_list_elems opt_kw_arg_list.

send(A) ::= send(B) DOT DOLLAR sexpr(C). { A.a = S->send_indirect(B.a, C.a); }

send(A) ::= send(B) DOT ID(C) LP RP. { A.a = S->call(B.a, *C.s); }
send(A) ::= send(B) DOT ID(C) arg_list RP. { A.a = S->call_args(B.a, *C.s); }

send(A) ::= ID(C) LP RP. { A.a = S->call(S->self(), *C.s); }

/* Keyword args */

kw_arg ::= ID(A) EQUAL send(B). { S->add_kw_arg(*A.s, B.a); }

kw_arg_list_elems ::= kw_arg_list_elems COMMA kw_arg.
kw_arg_list_elems ::= kw_arg.

kw_arg_list ::= arg_list_start kw_arg_list_elems.

send(A) ::= send(B) DOT ID(C) kw_arg_list RP. {
              A.a = S->call_kw_args(B.a, *C.s);
            }

/* Cascade args */

message_seq ::= message_seq fin ID(C). { S->cascade(*C.s); }
message_seq ::= ID(B). { S->cascade(*B.s); }

cascade_start ::= send(B) CASCADE. { S->start_cascade(B.a); }
cascade(A) ::= cascade_start message_seq RB. { A.a = S->end_cascade(); }

cascade(A) ::= send(B). { A.a = B.a; }

expr(A) ::= cascade(B). { A.a = B.a; }

/* Lambda */

lambda_start ::= LB. { S->start_lambda(); }

lambda_args ::= PIPE ID(B) PIPE. { S->def_arg(*B.s); }
lambda_args ::= .

expr(A) ::= lambda_start lambda_args seq(B) RB. { A.a = S->lambda(B.a); }

/* "Statements" */

stmt(A) ::= expr(B). { A.a = B.a; }

/* Conditions */

stmt(A) ::= IF expr(B) fin seq(C) fin END. { A.a = S->if_cond(B.a, C.a); }
stmt(A) ::= UNLESS send(B) fin seq(C) fin END. { A.a = S->unless(B.a, C.a); }

/* Import */

stmt(A) ::= IMPORT ID(B). { A.a = S->import(*B.s); }

stmt(A) ::= TRY fin seq(C) fin RESCUE fin seq(D) fin END. {
              A.a = S->ast_try(C.a, D.a);
            }

stmt(A) ::= ID(B) EQUAL expr(C). { A.a = S->assign(*B.s, C.a); }
stmt(A) ::= IVAR(B) EQUAL expr(C). { A.a = S->ivar_assign(*B.s, C.a); }
stmt(A) ::= RAISE expr(B). { A.a = S->raise(B.a); }
