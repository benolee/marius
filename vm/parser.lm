
%include {
#include "parser_state.hpp"
#include "parser_tokens.h"
#include <iostream>
}

%name mariusParser

%token_type   { marius::ParserToken }
%default_type { marius::ParserToken }

%token_prefix TK_

%left PLUS MINUS.
%left DIVIDE TIMES.

%extra_argument { marius::ParserState* S }
   
%syntax_error {
  S->set_syntax_error();

  std::cout << "Syntax error at line " << S->line()
            << ", column " << S->column() << std::endl;  
}

program ::= opt_fin seq(A) last_fin. { S->ret(A.i); }

opt_fin ::= .
opt_fin ::= opt_fin FIN.

last_fin ::= EOF.
last_fin ::= fin EOF.

fin ::= fin FIN.
fin ::= FIN.

start_seq ::= seq(B) fin. { S->recycle(B.i); }

seq(A) ::= start_seq expr(C). { A.i = C.i; }
seq(A) ::= expr(B). { A.i = B.i; }

class_start ::= CLASS. { S->start_class(); } 
class_body(A) ::= seq(B) fin END. { A.i = B.i; }

expr(A) ::= class_start ID(B) fin class_body(C). {
              S->ret(C.i);
              A.i = S->new_class(*B.s);
            }

def_start ::= DEF. { S->start_def(); }
def_body(A) ::= seq(B) fin END. { A.i = B.i; }

id_list ::= id_list COMMA ID(A). { S->def_arg(*A.s); }
id_list ::= ID(A). { S->def_arg(*A.s); }

def_args ::= .
def_args ::= LP id_list RP.

expr(A) ::= def_start ID(B) def_args fin def_body(C). {
              S->ret(C.i);
              A.i = S->end_def(*B.s);
            }

sexpr(A) ::= sexpr(B) MINUS  sexpr(C). { A.i = S->minus(B.i, C.i);  }
sexpr(A) ::= sexpr(B) PLUS   sexpr(C). { A.i = S->plus(B.i, C.i);   }
sexpr(A) ::= sexpr(B) TIMES  sexpr(C). { A.i = S->times(B.i, C.i);  }
sexpr(A) ::= sexpr(B) DIVIDE sexpr(C). { A.i = S->divide(B.i, C.i); }
sexpr(A) ::= NUM(B).                   { A.i = S->number(B.i);      }
sexpr(A) ::= ID(B).                    { A.i = S->named(*B.s);      }

send(A) ::= sexpr(B). { A.i = B.i; }
send(A) ::= send(B) DOT ID(C). { A.i = S->call(B.i, *C.s); }

/* Positional args */

arg_list_start ::= LP. { S->start_arg_list(); }
arg_list_elems ::= arg_list_elems COMMA send(A). { S->add_arg(A.i); }
arg_list_elems ::= send(A). { S->add_arg(A.i); }

opt_kw_arg_list ::= .
opt_kw_arg_list ::= COMMA kw_arg_list_elems.

arg_list ::= arg_list_start arg_list_elems opt_kw_arg_list.

send(A) ::= send(B) DOT ID(C) arg_list RP. { A.i = S->call_args(B.i, *C.s); }

/* Keyword args */

kw_arg ::= ID(A) EQUAL send(B). { S->add_kw_arg(*A.s, B.i); }

kw_arg_list_elems ::= kw_arg_list_elems COMMA kw_arg.
kw_arg_list_elems ::= kw_arg.

kw_arg_list ::= arg_list_start kw_arg_list_elems.

send(A) ::= send(B) DOT ID(C) kw_arg_list RP. {
              A.i = S->call_kw_args(B.i, *C.s);
            }

/* Cascade args */

message_seq(A) ::= message_seq(B) fin ID(C). {
                     S->recycle(B.i);
                     A.i = S->cascade(*C.s);
                   }

message_seq(A) ::= ID(B). { A.i = S->cascade(*B.s); }

cascade_start ::= send(B) CASCADE. { S->start_cascade(B.i); }
cascade(A) ::= cascade_start message_seq(C) RB. {
                 A.i = C.i;
                 S->end_cascade();
               }

cascade(A) ::= send(B). { A.i = B.i; }

expr(A) ::= cascade(B). { A.i = B.i; }

