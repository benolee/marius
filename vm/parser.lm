
%include {
#include "parser_state.hpp"
#include "parser_tokens.h"
#include <iostream>
}

%name mariusParser

%token_type   {marius::ParserToken}
%default_type {marius::ParserToken}

%left PLUS MINUS.
%left DIVIDE TIMES.

%extra_argument { marius::ParserState* S }
   
%syntax_error {  
  std::cout << "Syntax error!" << std::endl;  
}

program ::= opt_fin seq(A) fin. { S->ret(A.i); }

opt_fin ::= .
opt_fin ::= opt_fin FIN.

fin ::= fin FIN.
fin ::= FIN.

seq(A) ::= seq fin expr(B). { A.i = B.i; }
seq(A) ::= expr(B). { A.i = B.i; }

class_start ::= CLASS. { S->start_class(); } 
class_body(A) ::= expr(B) opt_fin END. { A.i = B.i; }

expr(A) ::= class_start ID(B) fin class_body(C). {
              S->ret(C.i);
              A.i = S->new_class(*B.s);
            }

def_start ::= DEF. { S->start_def(); }
def_body(A) ::= expr(B) opt_fin END. { A.i = B.i; }

expr(A) ::= def_start ID(B) fin def_body(C). {
              S->ret(C.i);
              A.i = S->end_def(*B.s);
            }

expr(A) ::= expr(B) MINUS  expr(C). { A.i = S->minus(B.i, C.i);  }
expr(A) ::= expr(B) PLUS   expr(C). { A.i = S->plus(B.i, C.i);   }
expr(A) ::= expr(B) TIMES  expr(C). { A.i = S->times(B.i, C.i);  }
expr(A) ::= expr(B) DIVIDE expr(C). { A.i = S->divide(B.i, C.i); }
expr(A) ::= NUM(B).                 { A.i = S->number(B.i);    }

recv(A) ::= ID(B). { A.i = S->named(*B.s); }
recv(A) ::= recv(B) DOT ID(C). { A.i = S->call(B.i, *C.s); }

expr(A) ::= recv(B) DOT ID(C). { A.i = S->call(B.i, *C.s); }

